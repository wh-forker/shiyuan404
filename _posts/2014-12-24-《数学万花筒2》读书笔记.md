---
layout: post
tags: 读书笔记
---

Description: 五彩缤纷的数学问题及知识    

34.正放与倒放的茶杯    
Description:    
n只正放茶杯，每次能够颠倒任意m只，问至少需要操作多少次使所有茶杯倒放    
Solution:    
n<=m时答案是显而易见的，这里我们讨论一下n>m的情况：    
1.n奇m偶：设翻转x个正放杯子为倒放茶杯，即有m-x个倒放杯子转化为正放茶杯，初始茶杯状态为正奇倒偶，每次实际变化为x-(m-x)=2x-m为偶数，所以奇偶状态不会改变，那么正偶倒奇的状态不可能出现，无解    
2.n偶m偶：从奇偶状态考虑，存在解，那么如何取得最小解。考虑n<2m的情况，我们可以操作两次将大部分的茶杯置反，那么能否一次操作把剩余的茶杯置反呢？当然需要向前面两次操作借茶杯，设两次操作后剩余x个茶杯，那么需要向前面借的茶杯数为m-x，列得方程(2m-(m-x))+x=n，求得x=(n-m)/2一定是整数，合法，带到x<=m中发现，n<=3m时都是可以3次完成的；考虑n>=2m的情况，同理考虑在ceil(n/m)次操作中选某两次借茶杯一定可以完成    
3.n偶m奇：从奇偶状态考虑，存在解，状态转化为：正偶倒偶->正奇倒奇->正偶倒偶->... 因此操作数一定为2的倍数，考虑到正倒是一种相对状态，那么这个问题可以看做是一个对称问题，也就是说一定存在一种对称，即初态->中间态和终态->中间态对称。枚举一下状态为(n,0),(n-m,m),..,(n/2,n/2),...,(m,n-m),(0,n)，而从(n,0)到(n/2,n/2)需要ceil(n/2/m)，这里的限制条件是n/2>=m即n>=2m，也就是n>=2m时需要2\*ceil(n/2m)次操作；考虑n<2m的情况，再次考虑正反相对的概念，每次操作完我们看做把所有的状态置反，这个时候我们的m=n-m，此时需要的操作数为2\*ceil(n/2/(n-m))    
4.n奇m奇，从奇偶状态考虑，存在解，状态转化为：正奇倒偶->正偶倒奇->正奇倒偶->正偶倒奇->... 初态为正奇倒偶，终态为正偶倒奇，故操作数为2X+1。如果我们先取出m个放在一边，问题就转化成(n-m)偶m奇的问题了同3中推导，然后需要操作一次处理剩余的m个，所以答案为2\*ceil((n-m)/2/m)+1，满足我们的必要条件的形式2X+1，限制条件为n>=2m，同样我们在考虑n<2m的情况，同2中所提，3次操作足矣    
[hdu3859](http://acm.hdu.edu.cn/showproblem.php?pid=3859) 就是这样的一道题，AC代码如下：
{% highlight c %}
#include <stdio.h>
typedef __int64 LL;
LL solve(LL n,LL m){
    if(n<m) return 0;
    if(n==m) return 1;
    if(n>m){
        if((n&1) && !(m&1)) return -1;
        if(!(n&1) && !(m&1)){
            if(n<2*m) return 3;
            else return (n+m-1)/m;
        }
        if(!(n&1) && (m&1)){
            if(n<2*m) return 2*((n/2+(n-m)-1)/(n-m));
            else return 2*((n/2+m-1)/m);
        }
        if((n&1) && (m&1)){
            if(n<2*m) return 3;
            return 2*(((n-m)/2+m-1)/m)+1;
        }
    }
}
int main(){
    LL n,m;
    while(scanf("%I64d%I64d",&n,&m)!=EOF){
        LL ans=solve(n,m);
        if(ans==-1)  printf("No Solution!\n");
        else  printf("%I64d\n",ans);
    }
    return 0;
}
{% endhighlight %}
    
<br>

37.可以公开的密码    
Description:    
结合阮一峰的博文对RSA加密算法加深了一下认识    
Details:    
1.选取两个不相等的素数p,q    
φ(n) = φ(pq) = φ(p)φ(q) = (p-1)(q-1)    
2.选取一个e,1<e<φ(n),且e与φ(n)互质    
3.求e对φ(n)的模反元素，使得    
ed ≡ 1 (mod φ(n))    
ed + tφ(n) = 1    
gcd(e,φ(n))=1，扩展欧几里得可以求得d    
4.检验，(n,e)为公钥，(n,d)为私钥，加密信息为x    
加密：    
x^e ≡ c (mod n)    
c = x^e - kn    
解密：    
c^d ≡ x (mod n)    
(x^e - kn)^d ≡ x (mod n)    
(x^e)^d ≡ x (mod n)    
x^(tφ(n)+1) ≡ x (mod n)    

<br>

40.11的规则    
Description:    
一种检测数能否被11整除的方法：如果奇数位之和与偶数位之和的差能被11整除则这个数能被11整除，反之亦然。那么0~9每个数字用恰好一次能组成被11整除的最大数和最小数是多少    
Solution:    
设奇数位和偶数位之和分别为x,45-x，那么差值为45-2x，为奇数，排除了差值为0的可能，x的范围为0+1+2+3+4<=x<=5+6+7+8+9即10<=x<=35，那么差值为-11或11，那么两个和分别为28和17，那么只需要枚举一下把数字分两类各5个，和分别为28和17即可。先求最大数，前几位可能为98765XXXXX，那么就是要看后五位能否凑出11，试试发现可以是9876524130。接下来看最小数，首位不是0，那么可能是10XXXXXXXXX的形式，考虑有1的分类且和为17的可能是12356,12347，最后满足条件的是1024375869    

<br>

92.狗的蹊跷表现    
Description：    
福尔摩斯故事《白银马》中有一段对话：“您有没有其他什么要提醒我注意的地方”，“最蹊跷的是狗在夜里的表现”，“狗夜里什么也没做呀”，“蹊跷之处就在这里”。    
给你一个序列： 1 2 4 7 8 11 14 16 17 19 22 26 28 29 41 44 根据福尔摩斯的启发，求序列的下一个数字    
Solution:    
不要看有什么，要看缺什么。很独特的想法啊。缺的数是3或5的倍数，因此下一个数为46    
<br>

109.我躲开了袋鼠吗    
Description：    
已知：    
1.这幢房子里唯一的动物是猫    
2.喜欢看月亮的动物都适合当宠物    
3.当我讨厌某种动物时，我会避开它    
4.没有动物是肉食动物，除非他们在夜间觅食    
5.没有猫不会抓老鼠    
6.除了这幢房子里的动物，别的动物不曾喜欢我    
7.袋鼠不适合当宠物    
8.只有肉食动物才捕杀老鼠    
9.我讨厌不喜欢我的动物    
10.夜间觅食的动物喜欢盯着月亮看    
判断：    
我是否避开了袋鼠    
Solution:    
设A表示这幢房子里唯一的动物，B表示猫，C表示喜欢看月亮的动物，D表示适合当宠物，E表示我讨厌某种动物，F表示避开它，G表示肉食动物，H表示在夜间觅食的动物，I表示猫，J表示抓老鼠，K表示喜欢我，L表示这幢房子里的动物，M表示袋鼠，N表示不适合当宠物，O表示捕杀老鼠，P表示肉食动物，Q表示不喜欢我的动物，R表示我讨厌的动物，S表示夜间觅食的动物，T表示喜欢盯着月亮看。    
!F->!E->!R->!Q->K->L->A->B->I->J->O->P->G->H->S->T->C->D->!N->!M   so M->F    

<br>
