---
layout: post
tags: algorithm
---

## Linear Programming

Description:     
{% highlight c  %}
   maximize:
      c[1]*x[1]+c[2]*x[2]+...+c[n]*x[n]
   subject to
      a[1,1]*x[1]+a[1,2]*x[2]+...a[1,n]*x[n] <= rhs[1]
      a[2,1]*x[1]+a[2,2]*x[2]+...a[2,n]*x[n] <= rhs[2]
       ......
      a[m,1]*x[1]+a[m,2]*x[2]+...a[m,n]*x[n] <= rhs[m]
{% endhighlight%}

Solution:     
Simplex Algorithm (click the link below to see the template)     


Wiki: [Simplex_algorithm](http://en.wikipedia.org/wiki/Simplex_algorithm)    
Essay: [单纯形法实现与应用](http://wenku.baidu.com/view/9f4c9e89680203d8ce2f24ae)    
Template: [uva10498.cpp](https://github.com/shiyuan/acm/blob/master/Study/Linear%20Programming/uva10498.cpp) (copy from [here](http://www.abandonzhang.com/archives/872))  

<br>
## Integer Partition


Description:

###Problem 1 
Suppose p(n,k) means the number of partition of an integer into parts the largest of which is k (this problem are always equivalent to the number of the partition of an integer into no more than k parts )     
p(n,k)=p(n-k,k)+p(n,k-1) (some of the parts appear more than once)    
p(n,k)=p(n-k,k-1)+p(n,k-1) (None of the part appears more than once)     
Boundary: n==0||k==1  p(n,k)=1    

###Problem 2 
Suppose p(n,k) means the number of partition of an integer into exactly k parts     
p(n,k)=p(n-k,1)+p(n-k,2)+...+p(n-k,k)=p(n-1,k-1)+p(n-k,k)    
Boundary: k==1  p(n,k)=1    

###Problem 3
Generating function,so many classical problems    
For example,we are supposed to get the number of partition of an integer into parts which have at most one of each distinct even part,we may get the generating function like this :     
{% highlight c  %}
 G(x)=(1+x+x^2+x^3...)*(1+x^2)*(1+x^3+x^6+...)*(1+x^4)*...
{% endhighlight  %}
We may simplify the function     
{% highlight c  %}
G(x)=(1+x^2)/(1-x) *(1+x^4)/(1-x^2) *...
G(x)=(1-x^4)/(1-x)/(1-x^2) * (1-x^8)/(1-x^4)/(1-x^2) * ...
G(x)=(1-x^4)/(1-x) *(1-x^8)/(1-x^2) * (1-x^12)/(1-x^3) * ...
G(x)=(1+x+x^2+x^3) * (1+x^2+x^4+x^6) * (1+x^3+x^6+x^9)*..
{% endhighlight  %}
It seems like we change the problem to get the number of partition of an integer into parts which have at most three times (though we may not simplify the origin problem,we just proof these two problem are equivalent)    

###Problem 4 
There are many other types of the problems,I can't write all of it down.    
Like getting the number of partition of an integer into parts which are the sum of some continuous number,we may list the equation and make some simplification,or the problem to get the number of partition of an integer into parts which only contains even numbers,we may solve it using the dynamic algorithm      

###Problem 5 
In number theory,the partition function p(n) represents the number of possible partitions of a number n,which is to say the number of distinct ways of representing n as a sum of natural numbers     
Formula：p(n)=p(n-1)+p(n-2)-p(n-5)-p(n-7)+...    
p(n)=Sigma((-1)^k \* p(n-k\*(3\*k-1)/2)) (k can be positive or negative)     


Exercises:      
[poj1283.cpp](https://github.com/shiyuan/acm/blob/master/Study/Integer%20Partition/poj1283.cpp) water    
[poj1664.cpp](https://github.com/shiyuan/acm/blob/master/Study/Integer%20Partition/poj1664.cpp) water     
[poj3181.java](https://github.com/shiyuan/acm/blob/master/Study/Integer%20Partition/poj3181.java) water     
[nbut1046.cpp](https://github.com/shiyuan/acm/blob/master/Study/Integer%20Partition/nbut1046.cpp) output the ways of partition    
[hit1402.cpp](https://github.com/shiyuan/acm/blob/master/Study/Integer%20Partition/hit1402.cpp) classical    
[hdu4651.cpp](https://github.com/shiyuan/acm/blob/master/Study/Integer%20Partition/hdu4651.cpp) formula    
[smart1101.cpp](https://github.com/shiyuan/acm/blob/master/Study/Integer%20Partition/smart1101.cpp) a funny dynamic problem     

### wtf
